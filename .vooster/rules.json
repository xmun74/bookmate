{
  "rules": [
    {
      "type": "prd",
      "content": "## 제품 요구사항 문서 (PRD)\n\n### 1. 소개\n\n\"BookMate\" - 친구와 함께 성장하는 소셜 독서 플랫폼\n교환독서 트렌드를 반영하여, 혼자가 아닌 친구들과 함께 책을 읽고 성장하는 경험을 제공하는 소셜 독서 웹/앱 서비스입니다.\n\n### 2. 목표\n\n*   독서 습관 형성을 위한 지속 가능한 동기부여\n*   친구와의 교환독서를 통한 깊이 있는 독서 경험\n*   독서 기록과 통계를 통한 성취감 제공\n*   새로운 책을 발견하고 의미 있는 토론을 할 수 있는 공간 제공\n\n### 3. 타겟 사용자\n\n*   20-30대 직장인, 대학생\n*   독서 습관을 만들고 싶지만 혼자서는 작심삼일인 사람\n*   친구들과 책 이야기를 나누고 싶은 사람\n*   SNS처럼 가볍게 독서 기록을 남기고 싶은 사람\n\n### 4. 주요 기능\n\n#### 4.1 교환독서 (핵심 차별화)\n\n- 교환독서 매칭\n   - 친구에게 교환독서 신청 (책 제안 + 기간 설정)\n   - 서로 같은 책을 읽거나, 각자 다른 책을 추천해서 교환\n   - 진행률 실시간 공유 (예: \"철수님이 50% 읽었어요!\")\n\n\n- 교환독서 타임라인\n   - 함께 읽는 친구의 하이라이트, 메모 실시간 피드\n   - 특정 페이지/챕터에 댓글 남기기\n   - 완독 후 서로 별점과 한줄평 교환\n\n\n\n#### 4.2 독서 모임\n\n- 모임 생성 및 관리\n   - 주제별 독서 모임 생성 (예: \"SF 소설 모임\", \"자기계발서 챌린지\")\n   - 멤버 초대 및 모임 공지사항\n   - 읽을 책 투표 기능\n\n\n- 일정 관리\n   - 모임 일정 캘린더 통합\n   - 멤버들의 독서 진도를 고려한 자동 일정 추천\n   - 오프라인 모임 장소 투표 및 공유\n\n\n\n#### 4.3 독서 캘린더\n\n- 일별 독서 기록\n   - 캘린더에서 날짜별 읽은 책 확인\n   - 각 날짜에 별점, 읽은 페이지, 독서 시간 표시\n   - 연속 독서 일수 뱃지 (스트릭)\n\n- 시각화\n   - 월별 독서량 히트맵\n   - 주간/월간 독서 시간 그래프\n   - 장르별 독서 비율 차트\n\n\n\n#### 4.4 올해의 책 & 추천\n\n- 베스트셀러/화제의 책\n   - 올해의 베스트 도서 큐레이션\n   - 장르별, 연령대별 추천\n   - 친구들이 많이 읽은 책 순위\n\n- 맞춤 추천\n   - 독서 취향 분석 기반 추천\n   - \"이 책을 읽은 사람은 이런 책도 읽었어요\"\n   - 친구가 좋아한 책 추천\n\n\n\n#### 4.5 독서 기록 & 공유\n\n- 하이라이트 & 메모\n   - 인상 깊은 구절 저장 (페이지 번호, 챕터 기록)\n   - 개인 메모 작성\n   - 하이라이트 카드 이미지로 SNS 공유\n\n- 독서 리뷰\n   - 별점, 한줄평, 상세 리뷰 작성\n   - 해시태그로 분류 (#힐링 #자기계발 #몰입감)\n   - 친구들의 리뷰 피드\n\n\n\n#### 4.6 독서 통계 & 챌린지\n\n- 개인 통계 대시보드\n   - 올해 읽은 책 수 / 목표 대비 달성률\n   - 가장 많이 읽은 장르\n   - 총 독서 시간\n   - 평균 별점, 가장 인상 깊었던 책\n\n- 챌린지\n   - 월별/연간 독서 목표 설정\n   - 챌린지 달성 시 배지 획득\n   - 친구와 독서량 비교 (선택적)\n\n\n\n#### 4.7 소셜 기능\n\n- 친구 관리\n   - 친구 추가/팔로우\n   - 친구의 독서 활동 피드 구독\n\n- 피드\n   - 친구들의 최근 읽은 책, 하이라이트, 리뷰\n   - 좋아요, 댓글 기능\n   - 책 추천 멘션 (@친구이름 이 책 어때?)\n\n### 5. 사용자 인터페이스(UI) 및 사용자 경험(UX)\n\n*   **디자인 컨셉:** 깔끔하고 세련되며 유치하지 않은 느낌\n*   **색상 구성:** 가독성이 좋은 중립적인 색상\n*   **타이포그래피:** 현대적이고 읽기 쉬운 글꼴 사용\n*   **반응형 디자인:** 웹/앱은 다양한 기기에서 완전히 반응형으로 동작해야 함\n\n### 6. 기술 요구사항\n\n*   **플랫폼:** 웹(반응형)\n*   **기술 스택:**\n    *   프론트엔드: Next.js 15, TypeScript, Tailwind CSS, TanStack Query\n    *   백엔드: Nest.js, TypeScript\n*   **데이터베이스:** PostgreSQL\n\n### 7. 성능 요구사항\n\n*   **응답 속도:** 모든 페이지는 2초 이내에 로딩되어야 함\n*   **확장성:** 많은 사용자와 도서를 처리할 수 있어야 함\n\n### 8. 보안 요구사항\n\n*   **데이터 보호:** 사용자 데이터는 암호화되어 보호되어야 함\n*   **인증:** 안전한 인증 및 권한 부여 메커니즘 적용\n\n### 9. 향후 고려사항\n\n*   전자책 플랫폼과의 연동\n*   AI 기반 도서 추천\n*   개인 맞춤형 독서 통계 및 인사이트 제공\n\n### 10. 결론\n\n이 문서는 독서 친구 웹/앱 개발을 위한 가이드로 활용된다. 본 요구사항을 준수함으로써 대상 사용자의 니즈를 충족하고 목표를 달성하는 제품을 만들 수 있다.",
      "writedAt": "2025-12-19T01:51:57.921Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항서 (TRD)\n  \n## 기술 스택\n\n- frontend\n: Next.js 16, TypeScript, Tailwind CSS, Zod, React Hook Form, @tanstack/react-query, ESLint, Prettier, Husky, Lint-staged, \n- backend\n: NestJS, PostgreSQL, Supabase Auth\n\n# Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 기능으로 도메인 분리.\n- **Layer-Based Architecture**: 프레젠테이션 레이어(Next.js 컴포넌트), 비즈니스 로직 레이어(Nest.js 서비스), 데이터 접근 레이어(PostgreSQL)로 분리.\n- **Feature-Based Modules**: 각 기능별로 모듈을 구성하여 코드 재사용성 및 유지보수성 향상.\n- **Shared Components**: 공통 UI 컴포넌트, 유틸리티 함수, 타입 정의 등을 shared 모듈에 저장.\n\n# Performance & Optimization Strategy\n\n- 캐싱 전략: 자주 변경되지 않는 데이터는 Redis 또는 Memcached를 사용하여 캐싱하여 데이터베이스 부하를 줄입니다.\n- 이미지 최적화: 이미지 크기 및 포맷을 최적화하여 로딩 속도를 향상시킵니다.\n- 코드 분할 및 지연 로딩: 초기 로딩 속도를 줄이기 위해 코드 분할 및 지연 로딩을 적용합니다.\n\n# Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 및 Nest.js 프로젝트 설정, PostgreSQL 데이터베이스 설정, OAuth 2.0 인증 서버 연동.\n- **Basic Security**: 기본적인 XSS, CSRF 방어 및 데이터베이스 보안 설정.\n- **Development Setup**: 개발 환경 설정 및 기본적인 CI/CD 파이프라인 구축.\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 개인 맞춤 추천 기능 구현, 검색 조건 상세 필터링 기능 추가.\n- **Performance Optimization**: 데이터베이스 인덱싱 최적화, 캐싱 전략 적용, 코드 최적화.\n- **Enhanced Security**: API rate limiting, 데이터 암호화, 보안 취약점 점검.\n- **Monitoring Implementation**: 로그 수집 및 분석, 성능 모니터링 시스템 구축.\n\n# 폴더 구조\n\n\n### 프론트엔드 레포\n| 경로                                    | 설명                    |\n| --------------------------------------- | ----------------------- |\n| /src/app/                               | Next.js 앱 라우터         |\n| /src/app/(protected)/                   | 보호된 라우트 그룹        |\n| /src/app/(protected)/dashboard/         | 대시보드 페이지           |\n| /src/app/api/                           | API 라우트 (프록시/Mock 등) |\n| /src/app/login/                         | 로그인 페이지             |\n| /src/app/signup/                        | 회원가입 페이지           |\n| /src/app/example/                       | 예시 페이지               |\n| /src/components/                        | 공통 컴포넌트             |\n| /src/components/ui/                     | shadcn/ui 컴포넌트        |\n| /src/features/                          | 피처(기능) 단위 모듈      |\n| /src/features/auth/                     | 인증 기능                 |\n| /src/features/auth/context/             | 인증 컨텍스트             |\n| /src/features/auth/hooks/               | 인증 훅                   |\n| /src/features/auth/types.ts             | 인증 타입 정의             |\n| /src/features/[featureName]/            | 다른 피처 예시            |\n| /src/features/[featureName]/components/ | 피처 컴포넌트             |\n| /src/features/[featureName]/pages/      | 피처 페이지               |\n| /src/features/[featureName]/constants.ts| 피처 상수                 |\n| /src/features/[featureName]/types.ts    | 피처 타입                 |\n| /src/features/[featureName]/utils.ts    | 피처 유틸                 |\n| /src/features/[featureName]/hooks/      | 피처 훅                   |\n| /src/features/[featureName]/lib/        | 피처 라이브러리/유틸      |\n| /src/constants/                         | 전역 상수                 |\n| /src/hooks/                             | 공통 훅                   |\n| /src/lib/                               | 유틸리티                  |\n| /src/lib/remote/                        | API 클라이언트            |\n| /public/                                | 정적 자산                 |\n\n### 백엔드 레포\n| 경로                                    | 설명                         |\n| --------------------------------------- | ---------------------------- |\n| /src/app/                               | Hono/NestJS 등 서버 엔트리포인트 |\n| /src/config/                            | 백엔드 환경설정                |\n| /src/http/                              | HTTP 유틸리티                  |\n| /src/middleware/                        | 서버 미들웨어                  |\n| /src/supabase/                          | supabase 서버 클라이언트        |\n| /src/features/                          | 백엔드 도메인/피처별 디렉토리   |\n| /src/features/auth/                     | 인증 관련 로직                  |\n| /src/features/auth/server/              | 인증 서버 로직                  |\n| /src/features/auth/types.ts             | 인증 타입 정의                  |\n| /src/features/[featureName]/            | 다른 피처 예시                 |\n| /src/features/[featureName]/backend/    | 피처 백엔드 로직               |\n| /src/features/[featureName]/constants.ts| 피처 상수                      |\n| /src/features/[featureName]/types.ts    | 피처 타입                      |\n| /src/features/[featureName]/utils.ts    | 피처 유틸                      |\n| /src/features/[featureName]/hooks/      | 피처 관련 훅                   |\n| /src/features/[featureName]/lib/        | 피처 라이브러리/유틸           |\n| /src/constants/                         | 전역 상수                      |\n| /supabase/migrations/                   | supabase 마이그레이션           |\n\n\n  ",
      "writedAt": "2025-12-19T01:51:57.921Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-12-19T01:51:57.921Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-12-19T01:51:57.921Z"
    }
  ]
}